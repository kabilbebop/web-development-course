# Qualit√© de code, refactoring et g√©n√©rateurs

## Les outils de qualit√© de code (ou revue de code statique)

### Exercice 1 : IntelliJ pour le code Java
Importer du profil d'inspection :
  - menu _File > settings_
  - _Editor > Inspection_ : choisir la roue de configuration üé° puis _Import profile_
  - importer le fichier XML ```IntelliJ-inspection-profile.xml``` √† la racine du projet

Lancer l'analyse :
  - Menu _Analyze > Inspect code_
  - dans le menu d√©roulant _Inspection profile_ en bas choisir le profil _WeightCars_ que nous venons d'importer
  - choisir _Custom scope_ puis ```...```
  - cr√©er un nouveau profil avec le bouton + et le nommer _Java_
  - choisir _production classes > weight-cars > weight-cars_main_ puis _Include recursively_

Lancer l'analyse : vous devriez avoir 6 warnings √† corriger.
Acc√©der √† la description du probl√®me en faisant un clic-droit sur le warning puis _Edit settings_.

### Exercice 2 : TSLint pour le code typescript
La liste des r√®gles peut √™tre configur√©e dans le fichier tsconfig.json
  - lancer la t√¢che Gradle verification > tsLint
  - constater que 4 warnings sont identifi√©s
  - essayer de corriger tous les warnings

## Les outils de refactoring

### Exercice 3 : Renommage d'une classe
Le nom de la classe ```Manufacturer``` n'est pas tr√®s parlant pour les marques de voiture, on veut la renommer en classe ```Brand```.
Dans cette exercice, vous allez utiliser le menu contextuel _Refactor_ pour renommer la classe :
  - clic-droit sur le nom de la classe, _Refactor > Rename_
  - IntelliJ va proposer d'impacter diff√©rentes portions du code : nommage des variables, commentaires, etc.
    Pour limiter les erreurs, on va se contenter de renommer le nom de la classe :
    - dans la 1√®re fen√™tre _Rename Variables_ : il ne faut rien cocher
    - dans la 2√®me fen√™tre _Refactoring Preview_, clic-droit pour exclure 
        - "usage in comments, strings and non-code files"
        - "references in generated code"
    - puis cliquer sur le bouton "do refactor"
  - constater le refactoring effectu√© en regardant les modifications dans l'onglet _Version Control > Local Changes_
    - seuls des fichier .java devraient avoir √©t√© modifi√©s
    - si ce n'est pas le cas, s√©lectionner tous les fichiers dans la vue _Local Changes_ puis clic-droit _Revert_
  - relancer les tests et l'application pour constater qu'ils fonctionnent toujours

### Exercice 4 : Factorisation de code
Lorsque l'on trouve du code dupliqu√©, on peut vouloir le factoriser pour appliquer le principe _DRY_.

C'est le cas dans ```CarResourceIntTest.java``` : 
  - √† la fin de ```createCar()``` et √† la fin de ```updateCar()```

IntelliJ facilite le refactoring :
  - s√©lectionner les lignes dupliqu√©es
  - clic-droit puis _Refactoring > extract > method_
  - nommer la nouvelle sous-m√©thode ```assertCarEqual```

Une fen√™tre s'ouvre pour proposer une signature diff√©rente : IntelliJ a d√©tect√© la duplication et vous propose de factoriser le code √† votre place.
  - accepter la nouvelle signature
  - accepter le remplacement de la factorisation du code dupliqu√©
  - constater le refactoring effectu√© en regardant les modifications dans l'onglet _Version Control > Local Changes_
  - relancer les tests pour voir si tout marche encore

## G√©n√©ration de code
Pour √™tre plus productif, il ne faut pas h√©siter √† faire appel au fonctionnalit√©s de l'IDE pour g√©n√©rer du code rapidement.

### Exercice 5
  - ouvrir la classe Generator
  - d√©commentez le code des m√©thodes ```testGenerator1``` et ```testGenerator2``` 
  - faire en sorte que les m√©thodes compilent et affichent les sorties suivantes

    ```
    [main] INFO playground.Generator - Film{name='The hitchhiker's guide to the galaxy', budget=50000000, date=2005-08-18}
    [main] INFO playground.Generator - Film{name='Snatch', budget=10000000, date=2000-11-15}
    ```

 Pour cela vous devez g√©n√©rer le code n√©cessaire dans la classe ```Film``` en bas du fichier :
 - faire un clic-droit dans le corps de la classe ```Film``` et utiliser le menu _Generate_ 
 - il est interdit de taper du code pour cette exercice!

## Gestion de d√©pendances avec Gradle
Nous allons observer comment la configuration des d√©pendances dans Gradle modifie les biblioth√®ques disponibles dans l'application.

### Exercice 6 : ajout d'une d√©pendance
- Ouvrir le fichier ```Dependencies.java``` et d√©commenter toutes les lignes
- R√©soudre l'erreur de compilation en modifiant le fichier ```build.gradle```

### Exercice 7 : m√©nage
Le but de cet exercice est de voir comment la transitivit√© des d√©pendances _Spring Data_ rendent redondantes les d√©pendances _Hibernate_.
Nous allons donc faire le m√©nage :
- Dans ```build.gradle```, chercher les d√©pendances _Spring Boot Data JPA Starter_ et _Hibernate_.
- Ouvrir le menu _File > Project structure_ puis _Libraries_ : rep√©rer les d√©pendances dans la liste
- Dans [mvnrepository.com](mvnrepository.com), V√©rifier si les d√©pendances _Hibernate_ sont bien inclues dans la d√©pendance _Spring Boot Data JPA Starter_
- Supprimer les d√©pendances d√©j√† inclues
- Lancer les t√¢ches _clean_ et _build_
- Ouvrir le menu _File > Project structure_ puis _Libraries_ 
    - les d√©pendances sont-elles toujours dans la liste?
    - Pourquoi?

